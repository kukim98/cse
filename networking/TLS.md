# TLS (Transport Layer Security)
## Introduction
With regular HTTP, a connection is opened, and then HTTP requests are sent to the server, and responses are received. Once, the connection is no longer needed, it is closed. With HTTPS, **a handshake occurs to agree on a key to be used for encryption and decryption of data before data can be transferred**. Now, data is encrypted using the key before being sent out and decrypted using the key.

## TLS 1.2
During the TLS handshake, the client sends the server a request with a list of supported key algorithms; this is the **client hello**. The server responds back with the **certificate**, which is the public key of the server. The client will then encrypt its symmetric key with the certificate and send it to the server; this is the **client key exchange**. Then the server responds back with an acknowledgement and saves the symmetric key that it got from the client. This completes the TLS handshake. All subsequent requests are encrypted and decrypted using the symmetric key exchanged during the client key exchange phase. One problem with this approach is the client key exchange exposes the symmetric key; if the private key of the server is leaked, then client data is at risk. Another problem is latency; the TLS handshake is a 4-way handshake.

## Certificates
With TLS 1.2, when the server responds back to the *client hello* with its public key, this response can be intercepted by a malicious user, in which case the client will receive the wrong public key. To ensure that the client receives the correct public key, the server first sends its public key to a **certificate authority** - third party services like Let's Encrypt and DigiSign. This will return a series of certificates. The **leaf/server certificate** includes the server name, the server's public key, and a signature for verification. The **intermediate/CA certificate** includes the CA name, CA's public key and a signature for verification. And the **root certificate** is installed in the operating system of the client's computer. To verify the validity of the certificate authority, the client checks the validity of the intermediate certificate using the key in the root certificate to verify the signature. The server certificate is then verified using the public key in the intermediate certificate. If the decryption results match, then the certificates have not been tampered with, and the client can safely use those keys.

## Diffie Hellman
This is an algorithm used to send information about the keys but not the actual keys themselves. The basic idea is that **the symmetric key is made with the client's private key, the server's private key , and the public key** (which can be sent out over the Internet). The combination of a party's private key with the public key is **unbreakable**; this means that it is safe to be sent over the Internet. 

## TLS 1.3
TLS 1.3 uses Diffie Hellman to exchange keys. Once the connection is established, the client will combine its private and public keys to create the unbreakable key. It then sends the public key and the unbreakable key to the server over the Internet. The server receives the packet and creates the symmetric key by combining the unbreakable key with its own private key. The server will send back the response with its private key and the public key combined. The client can combine the unbreakable key from the response and its private key to get the same symmetric key. By doing so, we reduce the risk of the keys being exposed and reduce latency by performing a 2-way handshake. The symmetric key is then used to encrypt and decrypt data.

## SSL Pinning
SSL pinning is a technique that can be used to increase security of certificate validation. The client will store portions of the certificate or a hash of it and will *pin* it to its memory. The saved data will be checked against the incoming certificate to ensure that the certificates are actually coming from the certified server.
